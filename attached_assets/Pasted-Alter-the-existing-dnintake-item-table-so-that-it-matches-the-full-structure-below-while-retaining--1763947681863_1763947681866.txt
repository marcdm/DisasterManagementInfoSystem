Alter the existing dnintake_item table so that it matches the full structure below, while retaining referential integrity and not breaking anything.

Use ALTER TABLE and related DDL, do NOT drop and recreate the table if it has data.

Preserve all existing data in dnintake_item.

Retain and enforce referential integrity with dnintake, donation_item, and unitofmeasure.

Do NOT break any existing code, UI, logic, workflows, APIs, or security fixes (CSP, security headers, TLS, cookies, SRI, cache-control, POST-only rules, etc.).

Only change what is needed on dnintake_item and its indexes/constraints.

Target structure (translate this into safe ALTERs):

create table dnintake_item
(
	donation_id integer not null,
	inventory_id integer not null,
	item_id integer not null,

	-- Batch information
	batch_no varchar(20) not null
		constraint c_dnintake_item_1a check (batch_no = upper(batch_no)),
	batch_date date not null
		constraint c_dnintake_item_1b check (batch_date <= CURRENT_DATE),
	expiry_date date not null
		constraint c_dnintake_item_1c check (expiry_date >= CURRENT_DATE),

	-- Units of measure
	uom_code varchar(25) not null
		constraint fk_dnintake_item_unitofmeasure references unitofmeasure,

	avg_unit_value decimal(10,2) not null
		constraint d_dnintake_item_1d check (avg_unit_value > 0.00),
	
	-- Quantities
	usable_qty decimal(12,2) not null
		constraint c_dnintake_item_2 check (usable_qty >= 0.00),
	defective_qty decimal(12,2) not null
		constraint c_dnintake_item_3 check (defective_qty >= 0.00),
	expired_qty decimal(12,2) not null
		constraint c_dnintake_item_4 check (defective_qty >= 0.00),

	status_code char(1) not null
		-- P=Pending verification, V=Verified
		constraint c_dnintake_item_5 check (status_code in ('P','V')),
	comments_text varchar(255),

	create_by_id varchar(20) not null,
	create_dtime timestamp(0) without time zone not null,
	update_by_id varchar(20) not null,
	update_dtime timestamp(0) without time zone not null,
	version_nbr integer not null,

	-- Referential integrity
	constraint fk_dnintake_item_intake foreign key (donation_id,inventory_id) 
		references dnintake(donation_id,inventory_id),
	constraint fk_dnintake_item_donation_item foreign key(donation_id,item_id)
		references donation_item(donation_id,item_id),

	constraint pk_dnintake_item primary key(donation_id,inventory_id,item_id,batch_no)
);

create index dk_dnintake_item_1 on dnintake_item(inventory_id, item_id);
create index dk_dnintake_item_2 on dnintake_item(item_id);


Requirements:

Use ALTER TABLE dnintake_item to:

Add any missing columns with the specified data types and NOT NULL where required.

Add or adjust check constraints c_dnintake_item_1a…c_dnintake_item_5.

Add or fix foreign keys:

fk_dnintake_item_intake → dnintake(donation_id, inventory_id)

fk_dnintake_item_donation_item → donation_item(donation_id, item_id)

fk_dnintake_item_unitofmeasure → unitofmeasure.

Ensure the primary key is (donation_id, inventory_id, item_id, batch_no).

Create the indexes:

dk_dnintake_item_1 on (inventory_id, item_id)

dk_dnintake_item_2 on (item_id)

Do not invalidate existing rows; if necessary, clean or default data before enforcing new constraints.

Do not modify other tables or any security-related configuration.

After migration:

All existing referential integrity is intact.

All current application features that use dnintake_item continue to work exactly as before, now with the enhanced structure and constraints.