You must update the dnintake_item table so that its structure matches the target DDL below, while:


Retaining full referential integrity


Not breaking any existing logic, UI, workflows, or behaviour


Not touching any security fixes (CSP, CSRF, auth/RBAC, cookies, sessions)


Not altering any other tables except for temporary FK drops/re-adds if required


Use this DDL as the final target structure:
create table dnintake_item
(
	donation_id integer not null,
	inventory_id integer not null,
	item_id integer not null,

	--Batch number assigned by manufacturer or by ODPEM (where there is no batch number).
	--If no batch number is assigned, set value of field to item code.
	--If batch does not exist, create it with a batch id and zero quantities (i.e. empty).
	--Update batch amounts with the amounts being taken in.
	batch_no varchar(20) --not null
		constraint c_dnintake_item_1a check (batch_no = upper(batch_no)),

	batch_date date not null
		constraint c_dnintake_item_1b check (batch_date <= CURRENT_DATE),

	expiry_date date not null
		constraint c_dnintake_item_1c check (expiry_date >= CURRENT_DATE),

	--Units in which quantity of item is measured
	uom_code varchar(25) not null
		constraint fk_dnintake_item_unitofmeasure references unitofmeasure,

	avg_unit_value decimal(10,2) not null
		constraint c_dnintake_item_1d check (avg_unit_value > 0.00),

	--Extended item cost =
	--	(usable_qty + defective_qty + expired_qty) * avg_unit_value
	ext_item_cost decimal(12,2) not null
		default ((usable_qty + defective_qty + expired_qty) * avg_unit_value)
		constraint c_dnintake_item_1c
		check (ext_item_cost = (usable_qty + defective_qty + expired_qty) * avg_unit_value),
	
	--Quantity/amount of usable/good item in inventory
	usable_qty decimal(12,2) not null
		constraint c_dnintake_item_2 check (usable_qty >= 0.00),
	
	--Quantity/amount of defective item in inventory
	defective_qty decimal(12,2) not null
		constraint c_dnintake_item_3 check (defective_qty >= 0.00),
	
	--Quantity/amount of expired item in inventory
	expired_qty decimal(12,2) not null
		constraint c_dnintake_item_4 check (defective_qty >= 0.00),

	status_code char(1) not null
		--P=Pending verification, V=Verified
		constraint c_dnintake_item_5 check (status_code in ('P','V')),

	comments_text varchar(255),

	create_by_id varchar(20) not null,
	create_dtime timestamp(0) without time zone not null,
	update_by_id varchar(20) not null,
	update_dtime timestamp(0) without time zone not null,
	version_nbr integer not null,

	constraint fk_dnintake_item_intake 
		foreign key (donation_id,inventory_id) 
		references dnintake(donation_id,inventory_id),

	constraint fk_dnintake_item_donation_item 
		foreign key(donation_id,item_id)
		references donation_item(donation_id,item_id),

	constraint pk_dnintake_item 
		primary key(donation_id,inventory_id,item_id,batch_no)
);

create index dk_dnintake_item_1 on dnintake_item(inventory_id, item_id);
create index dk_dnintake_item_2 on dnintake_item(item_id);


HARD CONSTRAINTS (DO NOT VIOLATE)


Retain referential integrity


Identify all foreign keys involving dnintake_item:


fk_dnintake_item_intake (donation_id, inventory_id) → dnintake(donation_id, inventory_id)


fk_dnintake_item_donation_item (donation_id, item_id) → donation_item(donation_id, item_id)


fk_dnintake_item_unitofmeasure (uom_code) → unitofmeasure(uom_code)




If you drop and recreate the table, you must:


Drop any dependent FKs in the correct order


Recreate them afterwards with identical definitions






Do not change any other table’s structure


No DDL changes to dnintake, donation_item, unitofmeasure or others, beyond temporary FK drops/re-adds.




Do not touch security or app code


No changes to Flask routes, templates, CSP headers, CSRF config, auth, cookies, or sessions.


This is a database-only migration.




Minimal, safe changes


First inspect the current live dnintake_item definition (\d dnintake_item) and compare to the target DDL.


Because the table is (or may be) empty, the simplest safe pattern is:


Drop FKs referencing it (if any),


Drop the table,


Recreate with the target DDL,


Recreate indexes,


Recreate FKs.







REQUIRED MIGRATION STEPS


Inspect schema


Use /mnt/data/drms-2.2.sql and \d dnintake_item to confirm the current structure and any existing constraints/indexes.




Find dependent FKs


Check whether any other tables reference dnintake_item. If any exist, record their names and definitions.




Perform safe rebuild


If there are dependent FKs:


ALTER TABLE <child_table> DROP CONSTRAINT <fk_name>; for each FK referencing dnintake_item.




Then:
2. DROP TABLE dnintake_item;
3. Run the target DDL exactly as provided above to create dnintake_item.
4. Create the indexes:


dk_dnintake_item_1 on (inventory_id, item_id)


dk_dnintake_item_2 on (item_id)




Finally, recreate any dropped foreign keys pointing back to dnintake_item (if there were any).




Verify


After migration:


\d dnintake_item must match the target DDL.


All FKs from dnintake, donation_item, and unitofmeasure are valid and enforced.


No other tables were altered.


The application runs with all existing workflows intact.







DELIVERABLE
Produce a PostgreSQL migration script (plain SQL or Alembic) that:


Safely replaces the existing dnintake_item table with the exact target DDL above.


Preserves all foreign key relationships and referential integrity.


Does not require any changes to application code, UI, workflows, or security configuration.


Is clearly commented to explain each step (dropping constraints, dropping table, recreating table, recreating indexes, re-adding constraints).

